#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
using namespace std;

typedef long l;

#define FORE(i,a,b) for(int i=(a);i<=(b);++i)
#define FOR(i,a,b) for(int i=(a);i<(b);++i)
#define REP(i,n)  FOR(i,0,n)

#define dump(x)  cerr << #x << " = " << (x) << endl;

#define MAX_N 100
#define MAX_K 100000

/*
int n=3, K=17;
int a[3] = {3,5,8};
int m[3] = {3,2,2};
// ans=YES
*/

int n=100;
l K=84194;
l a[100] = {35429, 62028, 60258, 76065, 59494, 29301, 82051, 55490, 49300, 3145, 54287, 13760, 29117, 51648, 56797, 3408, 48363, 84981, 32216, 60817, 47058, 13844, 70963, 55562, 27071, 63618, 75841, 78810, 44225, 39387, 21729, 33977, 27985, 40329, 89564, 97494, 55089, 92997, 15963, 23637, 56477, 35537, 5350, 23517, 49584, 29297, 9391, 96679, 10528, 26871, 11811, 65738, 88566, 90912, 7783, 67686, 35554, 91919, 60731, 37587, 34119, 52789, 30617, 53910, 19865, 646, 9681, 58564, 63635, 31901, 91611, 67383, 21530, 34246, 9000, 70115, 47066, 95493, 84447, 87936, 30362, 35831, 1730, 77457, 78445, 8707, 80189, 9176, 39055, 54387, 91476, 72100, 3260, 29166, 8112, 79404, 39448, 83362, 17837, 80957};
l m[100] = {23149, 68070, 82870, 81947, 62782, 52153, 85784, 7912, 22632, 40051, 26021, 53854, 71966, 24199, 36665, 28086, 51897, 54546, 41066, 18636, 25567, 27240, 30896, 58429, 51553, 33176, 11970, 92088, 9628, 22797, 4539, 28785, 53307, 62913, 4379, 14228, 36837, 45849, 97699, 35082, 60190, 26250, 34257, 75746, 63749, 67629, 83628, 67607, 26297, 92754, 89062, 72618, 12043, 79749, 58304, 73740, 42839, 42153, 47680, 62340, 49859, 45514, 14449, 2798, 43434, 91878, 38060, 29470, 43913, 30582, 35728, 26018, 20700, 50315, 5802, 38562, 43166, 50972, 94359, 53686, 97362, 57477, 63413, 61812, 53436, 84551, 97169, 53664, 99426, 36194, 70690, 2639, 65735, 80509, 97468, 40491, 18251, 6554, 92904, 32774};
// ans=YES

// [i]x[j] -> bool
int dp[MAX_N+1][MAX_K+1];

void solve() {
  memset(dp, -1, sizeof(dp));
  dp[0][0] = 0;
  for (int i = 0; i < n; i++) {
    for (int j = 0; j <= K; j++) {
      if (dp[i][j]>=0) {
	// `j` is already fulfilled . don't need to spend.
	// vertically only look at if `j` is already filled (over 0 or not)
	dp[i+1][j] = m[i];
	continue;
      }
      if (j<a[i]) {
	// a[i] is too much to fill `j`
	dp[i+1][j] = -1;
	continue;
      }
      if (dp[i+1][j-a[i]]>0) {
	// consume item to fill `j`.
	// horizontally look at if a[i] can be still consumed.
	dp[i+1][j] = dp[i+1][j-a[i]]-1;
      } else {	
	dp[i+1][j] = -1;
      }
    }
  }
  
  cout << (dp[n][K] >= 0 ? "YES" : "NO") << endl;
}

int main(int argc, char const *argv[]) {
  memset(dp, -1, sizeof(dp));
  solve();
}
